/*
 * Copyright 2007 Guy Van den Broeck
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.outerj.daisy.diff.tag;

import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import org.outerj.daisy.diff.output.OperationType;
import org.outerj.daisy.diff.output.TextDiffOutput;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.AttributesImpl;

/**
 * Outputs the diff result as HTML elements to a SAX ContentHandler. The
 * startDocument and endDocument events are not generated by this class. This
 * version is used for tag based diff results.
 */
public class TagSaxDiffOutput implements TextDiffOutput{

    private static final String OP_REMOVED = "removed";
    private static final String OP_ADDED = "added";
    private static final String prefix = "change";

    private final ContentHandler consumer;

    protected final List<TextOperation> results = new LinkedList<>();

    protected static class TextOperation
    {
        @Override
        public String toString() {
            return "[" + type + ": '" + text + "']";
        }

        protected final String text;
        protected final OperationType type;
        protected final int id;

        public TextOperation( final String text, final OperationType type, final int id ) {
            super();
            this.text = text;
            this.type = type;
            this.id = id;
        }

        protected TextOperation prev = null;
        protected TextOperation next = null;
    }

    public TagSaxDiffOutput(final ContentHandler consumer) {
        this.consumer = consumer;
    }

    private void outClearPart(final TextOperation op ) throws Exception {
        outBasicText(op.text);
    }

    private boolean insideTag = false;

    private void outBasicText(final String text) throws SAXException {
        final char[] c = text.toCharArray();

        final AttributesImpl noattrs = new AttributesImpl();

        for (int i = 0; i < c.length; i++) {
            switch (c[i]) {
            case '\n':
                consumer.startElement("", "br", "br", noattrs);
                consumer.endElement("", "br", "br");
                consumer.characters("\n".toCharArray(), 0, "\n".length());
                break;
            case '<':
                if (insideTag == false) {
                    final AttributesImpl attrs = new AttributesImpl();
                    attrs.addAttribute("", "class", "class", "CDATA",
                            "diff-tag-html");
                    consumer.startElement("", "span", "span", attrs);
                    insideTag = true;
                } else {
                    consumer.endElement("", "span", "span");
                    insideTag = false;
                }
                consumer.characters("<".toCharArray(), 0, "<".length());
                break;
            case '>':
                consumer.characters(">".toCharArray(), 0, ">".length());

                if (insideTag == true) {
                    consumer.endElement("", "span", "span");
                    insideTag = false;
                }
                break;
            default:
                consumer.characters(c, i, 1);
            }
        }
    }

    private int removedID = 1;

    private int addedID = 1;

    /**
     * {@inheritDoc}
     */
    private void outRemovedPart(final TextOperation op, final TextOperation next, final TextOperation prev ) throws Exception {
        final AttributesImpl attrs = attrs( op, next, prev );
        removedID++;
        consumer.startElement("", "span", "span", attrs);
        outBasicText(op.text);
        consumer.endElement("", "span", "span");
    }

    private AttributesImpl attrs( final TextOperation op, final TextOperation next, final TextOperation prev) {
        final String opType = opType( op.type );
        final AttributesImpl attrs = new AttributesImpl();
        attrs.addAttribute("", "class", "class", "CDATA", "diff-tag-"+opType);
        attrs.addAttribute("", "id", "id", "CDATA", opType + op.id);
        attrs.addAttribute("", "title", "title", "CDATA", "#"+opType + op.id);

        attrs.addAttribute("", "change-id", "change-id", "CDATA", changeId( op ) );
        attrs.addAttribute("", "previous", "previous", "CDATA", previous( prev ) );
        attrs.addAttribute("", "next", "next", "CDATA", next( next ) );

        return attrs;
    }

    private String changeId( final TextOperation prev ) {
        return opType(prev.type) + "-" + prefix + "-" + prev.id;
    }

    private String next( final TextOperation next ) {
        if( next == null ) {
            return "last-change";
        }
        return elementId( next );
    }

    private String previous( final TextOperation prev ) {
        if( prev == null ) {
            return "first-change";
        }

        return elementId( prev );
    }

    private String elementId( final TextOperation prev ) {
        return opType(prev.type) + prev.id;
    }

    private final String opType( final OperationType t ) {
        return t == OperationType.ADD_TEXT ? OP_ADDED : OP_REMOVED;
    }

    private void outAddedPart(final TextOperation op, final TextOperation next, final TextOperation prev ) throws Exception {
        final AttributesImpl attrs = attrs( op, next, prev );
        consumer.startElement("", "span", "span", attrs);
        outBasicText(op.text);
        consumer.endElement("", "span", "span");
    }

    @Override
    public void addAddedPart(final String text) throws Exception {
        results.add( new TextOperation( text, OperationType.ADD_TEXT, addedID ) );
        addedID++;
    }

    @Override
    public void addClearPart(final String text) throws Exception {
        results.add( new TextOperation( text, OperationType.NO_CHANGE, -1 ) );
    }

    @Override
    public void addRemovedPart(final String text) throws Exception {
        results.add( new TextOperation( text, OperationType.REMOVE_TEXT, removedID ) );
        removedID++;
    }

    @Override
    public void newline() {
        try {
            addClearPart( "\n" );
        }
        catch( final Exception e ) {
            // ignore
        }
    }

    @Override
    public void flush() throws Exception {

        linkOperations();
        flushOut();
    }

    protected void flushOut() throws Exception {
        for( final TextOperation op : results ) {
            doOp( op );
        }
    }

    protected void linkOperations() {
        final ListIterator<TextOperation> it = results.listIterator();
        if( ! it.hasNext() ) {
            return; // not even a single element?
        }

        while( it.hasNext() ) {
            final TextOperation op = it.next();

            if( op.type != OperationType.NO_CHANGE ) {
                op.prev = findPrev( results.listIterator( it.previousIndex() ) );
                if( it.hasNext() ) {
                    op.next = findNext( results.listIterator( it.nextIndex() ) );
                }
            }
        }
    }

    private TextOperation findNext( final ListIterator<TextOperation> it ) {
        while( it.hasNext() ) {
            final TextOperation op = it.next();
            if( op.type != OperationType.NO_CHANGE ) {
                return op;
            }
        }
        return null;
    }

    private TextOperation findPrev( final ListIterator<TextOperation> it ) {
        while( it.hasPrevious() ) {
            final TextOperation op = it.previous();
            if( op.type != OperationType.NO_CHANGE ) {
                return op;
            }
        }
        return null;
    }

    protected void doOp( final TextOperation op ) throws Exception {
        if( op.type == OperationType.ADD_TEXT ) {
            outAddedPart( op, op.next, op.prev );
        }
        else if( op.type == OperationType.REMOVE_TEXT ) {
            outRemovedPart( op, op.next, op.prev );
        }
        else if( op.type == OperationType.NO_CHANGE ) {
            outClearPart( op );
        }
        else {
            throw new RuntimeException( "Unrecognized operation type: " + op.type );
        }
    }
}
